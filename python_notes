Python coding

The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!

python --> means 2.7.3
python3 --> means 3.10.1

***

print("Hello")
# will show "Hello" in the terminal window

message = "Hello"
print(message)

# will give the same result, but this time we used a variable

print --> is a function
message --> is a variable
"Hello" --> is the value of the variable
# text that is not code is shown in orange

variables
# variables can contain letters, numbers, and underscores. They cannot start with a number
# variable names cannot contain spaces, instad we can use underscore
# don't use python programming words to describe variables
# variable names should be consise, but understandable
# be careful to use letter l and O because they can be confused with 1 and 0
 
 # strings
 # a string is a series of characters which can have single or double quotes, ie. "this is the text", or 'this is the text'
 
 upper --> capital letters
 lower --> small letters
 title --> First letter in first and second name is in capital letters
 
name = "ada lovelace"
print(name.title())
# this will print Ada Lovelace

name = "ada lovelace"
print(name.upper())
# this will print ADA LOVELACE

# combining strings is called concatenation

# adding whitespace & tabs to strings
\t - tab
\n - return, add whitespace between the lines

# remove whitespace
rstrip() --> stripping whitespace on the right side of the string
lstrip() --> stripping whitespace on the left side of the string
strip() --> stripping whitespace on both sides of the string

# printing a .py file directly in terminal instead from geany
- go to the right folder cd xx/xx
- python nameoffile.py

# print
- first write all variables, then print
name = "emma goldman"
print(name)

#numbers

3**2 --> means 3 elevated to 2
examples:
3**3=27 (3*3*3)
6**4+1296 (6*6*6*6)
# for every calculation Python return a result
# numbers with a decimal point is called a float

#str() function

age = 23
message = "Happy birthday + str(age) + "rd birthday!"
print(message)
# if we use the variable without str(), Pyhton don't understand how to interpret it
# for calculations in Geany, we use:
print(8+3) to show result in terminal window

# comments
# if we want to commnt out project in Python we can use #, Python will ignore what follows after this

# say hello to everyone.
print("Hello Pyhton People")
- Pyhton will only interpret and print the second line.

# lists
[] --> indicates a list
# elements in the list are separated by comma
['shoes', jacket' , 'gloves']
# if we want to refer to a specific element in the list we write:
colors = ['red' , 'green' , 'white' , 'black']
print(colors[0])
# the first element on the list is numbered 0 (index)
# we can add upper, lower or title to format the element
colors = ['red' , 'green' , 'white' , 'black']
print(colors[0].title())

bicycles = ['trek' , 'cannondale' , 'redline' , 'specialized']
print(bicycles[-1])
# -1 shows the last element on the list
# -2 shows the second last item om the list
# -3 returns the third item from the end and so forth.

# changing, adding and removing elements from the list
example:

motorcycles = ['honda','yamaha','suzuki']
print(motorcycles)

motorcycles[0] = 'ducati'
print(motorcycles)

# with motorcycles[0] = 'ducati' we change the value of the fist item on the list, from honda to ducati.

# append means to add an item, insert mean to at at the specified places in the list. Appending is useful if we don't have the complete list from the beginning and want to add continuously. Insert us useful if we already have a list but need to add something and it needs to be in a specific order.

# removing elements from the list
- can be done according to position or value
- del statement is removal
- example: 
del motorcycles[0] --> indicates which position is the list should be removed

# pop() method
- With the pop method you can choose any position in the list to print. 
first_owned = motorcycles.pop(0)
print(motorcycles.title())
- we can use both pop() and [x] to point to a position in a list, but pop will remove the item while [x] will not
- we can use both del and pop() to remove an iten from a list. If we want to continue to work with the removed ite, we need to use pop() method

# Removing item by value
- remove() method can be used when we want to remove an item without knowing it's position.
list.remove('whateveritemwewanttoremovefromthelist') 
- to be able to understand why we are using remove() we can name the variable and we can point to the variable to print statments about it.
- remove() only removes the first value and if we want it to remove a value every time it occurs, we need a loop

# printing a message to people on a list
guests = ['Kerstin' , 'Elsa' , 'Erika' , 'mother' , 'Louise' , 'Marie' , 'Birgitta' , 'Sandra']
print("Hello " + guests[2] + message + "\n")

- when we use pop() to remove values from alist and want to remove several, the number we want to remove will always be 0

# Sorting a list aphabetically with the sort() method
- It's permanent
- we can also do it in reverse order by writing reverse=True
list.sort() --> for alphabetical order
list.sort(reverse=True)

# sorted() method
- will organize the list in an alphabetical way but not permanently. It can also be used with reverse=True
print(sorted(list, reverse=True))

# reverse() method
- this method will print the list in the reverse order. It's permanent, but can be changes back using the reverse() again.

# len() to find the length of a list
- len(list) --> in interpreter
- print(len(list)) --> in ie. geany

# looping
- can be used if we want to use the same action for every item in a list
- for list in list:  --> to print each item on a new line/row. This way we can collectivize action for a list, instead of doing an individual action for each item on the list
- We can choose any name for the variable, ie. for guest in guests, or for cat in cats
- to use singular and plural in the way shown will help us to know if we are work with one item or a list
- we can include as many lines as we want
- A print that is outside of the indent concludes the loop. It will be printed only once.
- indentation is used to show that one line is connected to another
- indentation also helps with organization of blocks of code
- we have to be careful to use it correctly as:
# indent error stops the entire program. Syntax error runs until the point where there is a problem/error
- the : tells python to include what follows in the loop

# To know the index number of an item
- If we don't know the position of an item in a list and want to point to this item, we can:
- print(listname.index('nameofitem')) --> to know the index number of a specific item
- list[list.index('nameofitem')] --> if we want to print the name directly in the message

# range() function
- the range(1,5) will only show the numbers 1-4 and not 5. 
- for value in range(1,5):

# for the loop it's difficult to understand how to write variable within that will function according to expectations.
Example:

for value in range(1,51):
	print(value, "fuck you, I won't do what you tell me")
	names = ['anna', 'sven', 'danny', 'marie', 'olga']
	for name in names:
		print(name.title())
# for each line a new number will be printed. The message "fuck you..." will be printed next to each number. Because it's a loop and we told python to print the text repeatedly after print the value which is within range 1-51	

#Squares
squares = []
# this defines an empty list calles squares
for value in range(1,11):
#we are looping and using values from 1-10
	square = value**2
	# we are setting a variable inside the loop **2 (square)
	squares.append(square)
	# every new value is added to the list	
print(squares)
# printing complete list outside of the loop

- squares.append(value**2)
# we can write squares.append(value**2) directly to be more concise
# we should focus on writing code that is understandable first and not efficient

#list comprehension
squares = [value**2 for value in range(1,11)]
print(squares)
# as above but concise
threes = [value*3 for value in range(1,31)]
for three in threes:
	print(three)
	
# when it is written 'multiplies' --> it means all number divided by three (3,x,3)
# if it is written multiplied by --> value*3

digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
min(digits)
#prints the smallest value
max(digits)
# prints the biggest value
sum(digits)
# prints the totals sum of values in the list
numbers = list(range(1, 500))
# defining range of values

# press q if we want to stop an operation in the terminal

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[:4])
# printing the first four
# It is included as in last exercise, the last number is not printed
# when first index isn't specified it starts from the beginning of the list

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[2:])
# when the index at the end is not specified - 
# it will be printed until the end of the list  

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[-3])
# print the third player from the end

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[-3:])
# print the last three players

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print("Here are the first three players on my team:")
for player in players[:3]:
	print(player.title())
	# print the three first players each on a new line
	# specifying which numbers is don't direcly in for line 
	

my_foods = ['pizza', 'falafel', 'carrot cake']
friend_foods = my_foods[:]
# [:] refers to the whole my_foods list
# if we remove [:] the two lists will be printed exactly the same
# we want the two list to have a new and each a different item added

my_foods.append('cannoli')
friend_foods.append('ice cream')
# adding a new item on each list

print("My favorite foods are:")
print(my_foods)

print("\nMy friend's favorite foods are:")
print(friend_foods)
# the two prints show the same list because one = the other


items = ['hairbrush', 'tshirt', 'pants', 'socks', 'toothbrush', 'sweater', 'hoodie', 'glasses', 'shoes', 'computer', 'camera']
print("The first three items in the list are:")
for item in items[:3]:
	print(item.title())
print("\n\n")
# printing the first three items on the list

print("Three items from the middle of the list are:")
for item in items[4:7]:
	print(item.title())
print("\n\n")
# printing three items on index 4, 5 and 6

print("the last three items in the list are:")
for item in items[-3:]:
	print(item.title())
	# printing the last three items on the list
	

# tuple

# values that cannot change are called immutable
# an immutable list is called a tuple


dimensions = (200, 50)
print(dimensions[0])
#printing value in first position
print(dimensions[1])
# printing value in the second position

dimensions[0] = 250
print(dimensions[0])
# the value of index 0 cannot be change,
# when it is defined in the first variable
# if we want immutable values for the rectangle;
# it is good that python communicates and error

# PEP8 and styling code
https://www.python.org/dev/peps/pep-0008/
- code length should be no longer than 79 characters
- Some teams use a code length of 99 characters
- comment length should be no longer than 72 characters
- The code should aim to be neat and easy to read
- And also so it's possible to have three windows open at the same time
- Use blank lines to group parts of the program
- There may be code written with older python which doesn't support current style guide
# In Geany --> go to: edit - preferences - editor - indentation (chose replace tabs by spaces, tab width set to 4)
- ctrl I --> creates an indent
- ctrl U --> decreases an indent
- ctrl E --> makes text into a comment in the code

number = 42
number==42
True --> == testing an argument

# list with values printed differently
cars = ['audio', 'bmw', 'subaru', 'toyota']
for car in cars:
    if car == 'bmw':
        print(car.upper())
# if the car is a bmw it will be printed with upper case letters
    else:
        print(car.title())
# if it's any other car, it will be printed with first letter upper case
# if --> is a conditional test

car = 'bmw'
car == 'bmw'
# first car equals bmw
# second conditional test on if it's a bmw
# respons is True
car == 'audi'
# would return False

# Checking equality is case sensitive
car = 'Audi'
car == 'audi'
# will get the response: False

# managing case sensitivity when checking equality
car = 'Audi'
car.lower() == 'audi'
True
# we make sure all letters are lower case when testing
# if car is printed it will show 'Audi'still. It doesn't change the variable permanently
# can for example be used to check availability of usernames

requested_topping = 'mushrooms'
if requested_topping != 'anchovies':
    print("Hold the anchovies!")
# the requested topping is mushrooms
# if the requested topping is not anchovies, print 'Hold the anchovies!'
# != mean NOT

# mathematical comparison
age = 19
# defining that the age is 19
age < 21
# asking if the number is less than 21
age <= 21
# asking if the number is smaller or equals 21
age > 21
# asking if the number is higher than 21
age >= 21
# asking if the number is highers than or equals 21

# checking multiple conditions
age_o = 22
age_1 = 18
age_0 >= 21 and age_1 >= 21
# asking if age_0 is bigger than or equals 21, and
# if at the same time age_1 is bigger than or equals 21, which as false
age_1 = 22
# age_1 now equals 22
age_0 >= = 21 and age_1 >= 21
# with the change of age_1 variable, the conditions are not met for both

age_0 = 18
# changing variable to 18
age_0 >= 21 or age_1 >= 21
# asking if age_0 or age_1 is bigger than or equals 21
# the condition is met for age_1 which was changed to 22 
# when using or the conditions don't have to be met for both

# checking if a certain value is in the list
banned_users = ['andrew', 'carolina', 'david']
user = 'marie'
if user not in banned_users:
    print(user.title() + ", you can post a response if you wish.")
# if the user is not on the list banned_users then a message will be printed\
# including the users name

banned_users = ['andrew', 'carolina', 'david']
user = 'andrew'
if user not in banned_users:
    print(user.title() + ", you can post a response if you wish.")
else:
    print(" good try!")
# if the user is on the list on banned_users the else option will be printed

# boolean expression (another name for a conditional test)
game_active = True
can_edit = False
# used to keep track  of certain conditions, such as if a game is running\
# or if a user can edit content on a website
***
a = 1			a = 1
b = a ==1		b = a == 2
b			b
# returns True		# returns False

***
if user_name in list_comrades \
        and user_password == comrade_password \
        or user_name in list_xweser_comrades \
        and user_password == xweser_password:
    # important to define the whole comparison after 'or" function
    # not to think about it as spoken language, but define every step again
    # otherwise the function misbehave
    # when there are two lists --> on that is a general and one that is xweser, that have different login
    
# variable return_comrade = True/False if the criteria are met
return_comrade = (user_name in list_comrades
                  and user_password == comrade_password
                  or user_name in list_xweser_comrades
                  and user_password == xweser_password)

if not return_comrade:
    # the variable return_comrade is used
    # statement: if variable: means it needs value True as a return for action
    # if not variable: means that the variable value is not True (is False)
    # that the conditions were not met.
    # in this case if False (if not True)
    # the "not a correct login" message prints
    print(
        "We are sorry, but your user name and password "
        "does not match, please try again."
    )


# if-elif-else
# admissions for anyone under age 4 is free.
# admission for anyone between the ages of 4 and 18 is $5.
# admission for anyone age 18 or older is $10.

age = 12
if age < 4:
    print("Your admission cost is $0.")
    # tests if the person is 4 years old
elif age < 18:
    print("your admission cost is $5.")
    # is another conditional test that will only run if the previous fails
    # because the first test was False, this run and proves True
    # the text is printed
else:
    print("Your admission cost is $10.")

age = 12
if age < 4:
    price = 0
elif age < 18:
    price = 5
else:
    price = 10
print("Your admission cost is $" + str(price) + ".")
# this code is more efficient and easier to modify

# using multiple elif blocks
age = 12
if age < 4:
    price = 0
elif age < 18:
    price = 5
elif age < 65:
    price = 10
else:
    price = 5
print("Your admission cost is $" + str(price) + ".")
# this adds and extra condition. if the person is less than 65 years it cost 10
# but if not then it cost 5, so everyone older than 65 will pay 5

# we can also do the code without else: at the end
age = 12
if age < 4:
    price = 0
elif age < 18:
    price = 5
elif age < 65:
    price = 10
elif age >= 65:
    price = 5
print("Your admission cost is $" + str(price) + ".")
# the last elif mean that if a person is more than or equal to 65 then \
# the cost is 5
# the else block points to everything that is not included in if or elif

# testing multiple conditions
requested_toppings = ['mushrooms', 'extra cheese']
if 'mushrooms' in requested_toppings:
    print("Adding mushrooms.")
if 'pepperoni' in requested_toppings:
    print("Adding pepperoni.")
if 'extra cheese' in requested_toppings:
    print("Adding extra cheese.")
print("\nFinished making your pizza!")
# all three are independent tests and evaluated
# mushrooms andextra cheese are found in the list and are printed
# print last text message
# the code wouldn't work with elif since elif stops after a test passes
# because of this only mushrooms would be added and printed together\
# with the text message in the end

# checking for special items
requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']
for requested_topping in requested_toppings:
    if requested_topping == 'green peppers':
        # if the requested topping is green peppers,
        # it will be printed that we are out right now
        print("Sorry, we are out of green peppers right now.")
    else:
        print("Adding " + requested_topping + ".")
        # all other items on the list will be added

# checking that a list is not empty
requested_toppings = []
if requested_toppings:
    for requested_topping in requested_toppings:
        print("Adding " + requested_topping + ".")
    print("\nFinished making your pizza!")
else:
    print("Are you sure you want a plain pizza?")
    
# using multiple lists
available_toppings = ['mushrooms', 'olives', 'green peppers',
                      'pepperoni', 'pineapple', 'extra cheese']
# this list could also be made as a tuple if there is a stable selection

requested_toppings = ['mushrooms', 'french fries', 'extra cheese']
for requested_topping in requested_toppings:
    if requested_topping in available_toppings:
        # if the item in requested toppings is also on the list of available\
        # toppings, then it will be added
        # if not, then a message will be shared that we don't have it
        # because it's a for loop it will go through and check all items
        print("Adding " + requested_topping + ".")
    else:
        print("Sorry, we don't have " + requested_topping + ".")
print("\nFinished making your pizza!")


# if-elif-else in for loop
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# ~ print(numbers)
for number in numbers:
    if number == 1:
        # be careful how to write condition
        # 1 == numbers mean if 1 is in numbers
        # if 1 in numbers will print 'st' every time it finds number 1
        # and because it's a loop it will repeat even for other numbers
        print(str(number) + "st")
    elif number == 2:
        # it's also possible to write elif 2 == number:
        # watch out for if it's singular or plural reference to list
        # number or numbers
        print(str(number) + "nd")
    elif number == 3:
        print(str(number) + "rd")
    else:
        print(str(number) + "th")
        # make sure else is in the for loop

# code structure  
users = ['admin', 'tor', 'greta', 'linnea', 'ben']
if users:
    for user in users:
        if user == 'admin':
            # if the user in the list is called 'admin'
            print("Hello " + user.title() + ", there is no new updates.")
            # printing 'hello admin, there is no updates'
        else:
            print("Welcome " + user.title() + "!")
            # for any other user printing 'Welcome user!'
else:
    print("We need to find some users!")
    # else on line 8 is outside of the loop
    # this code runs only if the first if statement "if users" falls:
    # if the list is empty

# a simple dictionary
alien_0 = {'color': 'green', 'points': 5}
# dictionary storing different values about a particular item
print(alien_0['color'])
print(alien_0['points'])
# printing 'green' and '5'
# a dictionary wrapps the information in {}
# a key-value pair is a set of value associated with each other
# every key is connected to its value by a colon
# the key-value pairs are separated by commas
# one key value pair is {'color': 'green'}
# 'color' is a key and the value is 'green'
# we can store as many as we want

# starting with an empty directory
alien_0 = {}
alien_0['color'] = 'green'
alien_0['points'] = 5
# adding values to the dictionary
print(alien_0)
# this prints the dictionary as one line:
# {'color': 'green', 'points': 5}

# accessing values in a dictionary
print(alien_0['color'])
# this print the value green only
new_points = alien_0['points']
# new points equals alien_0 points which is 5
print('You just earned ' + str(new_points) + ' points!')

# adding new key-value pair
alien_0 = {'color': 'green', 'points': 5}
print(alien_0)

alien_0['x position'] = 0
alien_0['y position'] = 25
print(alien_0)

# starting with an empty dictionary
alien_0 = {}
alien_0['color'] = 'green'
alien_0['points'] = 5
print(alien_0)
# works like adding a new key-value pair
# normally we start with empty dictionaries

# modifying values in a dictionary
alien_0 = {'color': 'green'}
print('The alien is now ' + alien_0['color'] + '.')

alien_0['color'] = 'yellow'
print('The alien is now ' + alien_0['color'] + '.')
alien_0 = {'x_position': 0, 'y_position': 25, 'speed': 'medium'}
print("Original x_position: " + str(alien_0['x_position']))
if alien_0['speed'] == 'slow':
    # remember to include colon after the condition
    # if the alien's speed is slow, it will move one unit to the right
    x_increment = 1
elif alien_0['speed'] == 'medium':
    x_increment = 2
    # the original speed is medium
    # the alien will move two units to the right
else:
    x_increment = 3

alien_0['x_position'] = alien_0['x_position'] + x_increment
# the new position is the old position + the x_increment
print("New x_position: " + str(alien_0['x_position']))
# printing the new position

# removing key-value pair
alien_0 = {'color': 'green', 'points': 5}
print(alien_0)

del alien_0['points']
print(alien_0)
# this deleted the selected value, in this case 'points'
# the deleted key-value pair is removed permanently

# using for loop to print value in a dictionary
user_0 = {
    'username': 'efermi',
    'first': 'enrico',
    'last': 'fermi',
}
# creating a dictionary containing information about a person
# this is stored in several key-value pair

for key, value in user_0.items():
    print("\nKey: " + key)
    print("Value: " + value)
    
# making a dictionary with favorite languages
favorite_languages = {
    'jen': 'python',
    'sarah': 'c',
    'edward': 'ruby',
    'phil': 'python',
}
print("Sarah's favorite language is " +
      favorite_languages['sarah'].title() + ".")
# printing Sarah's favorite language

for name, language in favorite_languages.items():
    print(name.title() + "'s favorite language is " +
          language.title() + ".")
print("\n")
# key() method
# returns  a list of all keys
for name in favorite_languages.keys():
    print(name.title())
    # this for loop is the same as:
    # for name in favorites_languages:
print("\n")
friends = ['phil', 'sarah']
for name in favorite_languages.keys():
    print(name.title())

    if name in friends:
        print("Hi " + name.title() +
              ", I see you favorite language is " +
              favorite_languages[name].title() + "!")
    if 'erin' not in favorite_languages.keys():
        print("Erin, please take our poll!")

# looping through dictionaries keys in order
for name in sorted(favorite_languages.keys()):
    print(name.title() + ", thank you for taking the poll.")
    # with sorted() we can organize keys in alphabetical order
print("\n")

# looping through all values in a dictionary with values() method
# this returns a list without keys
print("The following languages have been mentioned:")
for language in sorted(favorite_languages.values()):
    print(language.title())
    # pulls all values from the list
    # values() method don't check for repeats
print("\n")

# using set to not repeat value
for language in set(favorite_languages.values()):
    print(language.title())
    # set() identifies unique items
    # therefore there is nor repetition of values when printing

# nesting
alien_0 = {'color': 'green', 'points': 5}
alien_1 = {'color': 'yellow', 'points': 10}
alien_2 = {'color': 'red', 'points': 15}
# making a dictionary with three aliens
aliens = [alien_0, alien_1, alien_2]
# including the three aliens in a list

for alien in aliens:
    print(alien)
    # printing the list

aliens = []
# creating an empty list
for alien_number in range(30):
    # defining how many time to loop:
    # each time a new alien is created
    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}
    # adding a new alien and key-value pairs to the dictionary
    aliens.append(new_alien)
    # adding the new alien to the list

for alien in aliens[0:3]:
    # for the first three aliens
    if alien['color'] == 'green':
        # if the aliens color is green
        alien['color'] = 'yellow'
        # it will be changed to yellow
        alien['speed'] = 'medium'
        # and the speed will be changed from slow to medium
        alien['points'] = 10
        # the points will change from 5 to 10
    elif alien['color'] == 'yellow'
    # if the alien color is yellow, it will change to red
        alien['color'] = 'red'
        alien['speed'] = 'fast'
        # the speed will change to fast
        alien['points'] = 15
        # the points will change to 15

print("\n")
for alien in aliens[:5]:
    # creating a for loop to print the first five aliens
    print(alien)
print("...")

print("Total number of aliens: " + str(len(aliens)))
# printing the total number of aliens

favorite_languages = {
    'jen': ['python', 'ruby'],
    'sarah': ['c'],
    'edward': ['ruby', 'go'],
    'phil': ['python', 'haskell'],
}
# adding items to the lists
print("********************")
for name, languages in favorite_languages.items():
    if language == 1:
        print("\n" + name.title() + "'s favorite languages are:")
    else:
        print("\n" + name.title() + "'s favorite language is:")
        for language in languages:
            print("\t" + language.title())
            # the item/or items will all be printed

print(len(languages))

# adding dictionary to list
# for loop with str()

person_3 = {}
person_3['first name'] = 'sam'
person_3['last name'] = 'kant'
person_3['age'] = 13
person_3['city'] = 'barcelona'

people = []
people.append(person)
people.append(person_2)
people.append(person_3)

for each_person in people:
    for name, info in each_person.items():
        print(name.title() + ": " + str(info).title())
    print("\n")

****

FORMATING OF VARIABLES IN STRINGS
# THE SECOND EDITION OF THE BOOK IS DIFFERENT:
# The introduce method is called F-STRINGS
# Instead of: variable_0 + variable_1
# The new way is: f"{variable_0} {variable_1}"
# where "f" stands for format.
# In practice it can look like this:

# Crash Course Book - edition 1:
variable_0 = "This is the way we used in the edition: "
variable_1 = "ONE"
message_one = variable_0 + variable_1

print(message_one)

# Crash Course Book - edition 2:
variable_0 = "This is the way we used in the edition: "
variable_2 = "TWO"
message_two = f"{variable_0} {variable_2}"
# the "" are quite confusing in this new format.
# the "quotations "  mark the f-string beginning and end
# no + sign used, just space, for easier reading (styling the code)
print(message_two)

# This can be done with longer strings as well, for example
name = 'leo'
surname = 'peltier'
full_name = f"{name} {surname}"
print(f"Sending you my love, {full_name.title()}.")
# only 'f' stayed before the "quotations"
# no + sign
# .title in {} together with the variable
# Everything (but 'f') within "quotations" to mark/define it as one string
# all of that in print(brackets)

***


# input() function
- pauses the program and waits for the user to enter some text

message = input("Tell me something,and I will repeat it back to you: ")
print(message)
# the user is asked to enter information which will then be repeated back
# the text edition won't be able to run this program
# we need to use terminal

name = input("Please enter your name: ")
print(f"\nHello, {name}!")
# input() makes the request and then waits for input
# when entering name, the greeting and name is printed
# the name in print refers to the answer

prompt = "If you tell us who your are, we can personalize the messages you see."
prompt += "\nWhat is your first name? "
name = input(prompt)
print(f"\nHello, {name}!")
# building a multi-line string
# the first one is variable
# the second using += is adding a string to the first string called 'prompt'
# this will be printed on a new line


# using int()
age = input("How old are you? ")
# if anser ie. with 15
# writing age, terminal will return '15'
# if writing age >= 18 there will be an error
# it's not possible to compare a string with a numerical value
# if we write age == 15 it will return False
age = int(age)
age >= 15
# returns True because the string is converted to a numerical representation
# the comparison is therefore possible


# modulo operator
# divides on number by anther number and returns what remains
ie.
	4 % 3 → returns 1
	5 % 3 → returns 2
	6 % 3 → returns 0 (when a number is even 0 is returned)
	
number = input("Enter a number, and I'll tell your if it's even or odd: ")
number = int(number)

if number % 2 == 0:
    # even numbers can be divided by two
    # when writing 6 % 3 it returns zero because nothing remains
    # while if I write 5 % 3 it will return 2
    # so this means that if this condition is met, the number is even
    print(f"\nThe number {number} is even.")
else:
    print(f"\nThe number {number} is odd.")


# while loop
current_number = 1
# assigning current number the value 1
while current_number <= 5:
    # as long as the current number is less than or equal to 5
    print(current_number)
    # printing the current number, which the first time is 1
    current_number += 1
    # adding 1 to the value of the current number, which then become two etc
    # the loop stops running when it reaches 5


# repeating a message using input()
message = input("Tell me something,and I will repeat it back to you ")
print(message)
# the user is asked to enter information which will then be repeated back
# the text edition won't be able to run this program
# we need to use terminal to run the program:
go to the repository
python nameofproject.py

prompt = "Tell me something,and I will repeat it back to you --> "
# request to make an input
prompt += "Enter quit to end the program: "
# if the input is quit. the program will stop running
message = ""
while message != 'quit':
    message = input(prompt)

    if message != 'quit':
        print(message)

# using the variable active = True as the condition for the program to run
active = True
# variable that the program is in an active state
while active:
    message = input(prompt)
    # when the program is active the message is the input

    if message == 'quit':
        # if the message is 'quit'
        active = False
        # the first variable is no longer true

    else:
        print(message)
        # if the forst variable continues to be true,
        # if the input is anything else than 'quit'
        # the message should be printed

*****

Exercise using input() with conditional test (7-4 in the book)

request = "\nPlease enter all the toppings that you want on your pizza: "
# asking for input on which toppings are wanted on the pizza

while True:
    # as long as True the program will continue
    toppings = input(request)
    # toppings means the input in the request
    response = (f" I'll add {toppings} to your pizza!")
    # every time a new input on toppings is shared
    # a message confirming that the toppin has been added will be printed
    if toppings == 'quit':
        # if the user will write quit instead of a topping the program will stop
        print("\nThank you for your order!")
        # and this message will be printed instead
        break
        # break exits the program
    else:
        print(response)
        # if 'quit' is not written the program will continue
        
*****

Exercise on using conditions - active, while and if (7-7)

question = "How old are you? "
active = True

while active:
    answer = input(question)
    if answer == 'quit':
        # the answer is 'quit'
        print("Hope to see you soon!")
        # this message will be printed
        active = False
        # the condition is no longer true

    elif int(answer) < 3:
        print("Welcome. Your ticket is free!")
        # if the input is less than 3
    elif int(answer) < 12:
        print("Welcome! Your ticket cost $10")
        # if the input is less than 12
    elif int(answer) > 12:
        print("Welcome! Your ticket cost $15")
        # if the input is more than 12


--------

# using break instead of active
question = "How old are you? "

while True:
    answer = input(question)
    if answer == 'quit':
        print("Hope to see you soon!")
        break

    elif int(answer) < 3:
        print("Welcome. Your ticket is free!")
    elif int(answer) < 12:
        print("Welcome! Your ticket cost $10")
    elif int(answer) > 12:
        print("Welcome! Your ticket cost $15")

*******

# moving items from one list to another
# using pop(), append(), sort()

unconfirmed_users = ['alice', 'brian', 'candace']
confirmed_users = []
# creating an empty list where we move confirmed users

while unconfirmed_users:
    current_user = unconfirmed_users.pop()
    # with pop() we are able to remove from the list of unconfirmed users
    # and still be able to work with the item
    # pop() removes from the end of the list

    print(f"Verifying user: {current_user.title()}")
    # the current user is the one that was removed from unconfirmed users
    confirmed_users.append(current_user)
    # adding to the list of current users

confirmed_users.sort()
# organizing the list in alphabetical order
print("\nThe following users have been confirmed:")
for confirmed_user in confirmed_users:
    print(confirmed_user.title())
    # printing the users that have just been moved to the list of \
    # confirmed users


# storing input in a dictionary
# using flag, input(), while, if, for
responses = {}
# creating an empty dictionary

polling_active = True
# setting flag

while polling_active:
    name = input("\nWhats i your name?")
    # asking for name
    response = input("Which mountain would you like to climb someday?")
    # when submitted, this question follows

    responses[name] = response
    # key is the name
    # the value is the response on the question 'which mountain...'
    # key-value pair is added to the dictionary

    repeat = input("Would you like to let another person respond? (yes/ no) ")
    # if the response to this question is yes,
    # the loop will start from the beginning
    if repeat == 'no':
        # if the answer is no, the loop will finish
        polling_active = False
        # if that answer is no, the condition is no longer met

print("\n--- Polling results ---")
for name, response in responses.items():
    print(f" {name.title()} would like to climb {response.title()}.")
    # the result will be printed

****
# polling exercise with several questions and multiple exit points

question_1 = "What is your name?\n"
question_1 += "If you want to exit write 'quit'."

question_2 = "\nIf you could visit one place in the world..."
question_2 += "\nWhere would you go?\n"

question_3 = "Do you want another person to respond yes/no \n\n"

answers = {}

active = True
while active:
    name = input(question_1.lower())
    # name is whatever input is given to this question
    if name.lower() == 'quit':
        # adding the possibility to quit at any point in the program
        print("Goodbye!")
        break

    print(f" \nHello {name.title()}!\n")
    # using the info that was given and printing a greeting

    answer = input(question_2.lower())
    # answer is whatever input is given to question_2

    if answer.lower() == 'quit':
        print("See you next time.")
        break

    print(f"\n{answer.title()} sounds amazing!")
    # printing a response including the given information

    answers[name] = answer
    # adding the key 'name' and the value 'answer' to the dictionary 'answers

    repeat = input(question_3)
    # repeat is whatever input is given to question_3
    print("\n")
    if repeat == 'no':
        active = False

    print("\nThese are the places in the world we want to visit most:")
    for name, answer in answers.items():
        print(f"{answer.title()}")
        # needed to indent the for loop to be able to give the option to\
        # quit any time


# defining a function
def greet_user():
    # defining the function
    """Display a simple greeting."""
    # using tripple quotation with text is called a docstring
    # the tripple quotation is known to python
    print("Hello!")
    # anything after colon is the body of the function


greet_user()

# to call a function we write the name of the function
# any other necessary info is added in the parenthesis

# passing information to a function
users = ['anna', 'jesse', 'can']


def greet_user(user):
    """Display a simple greeting."""
    print(f"Hello, {user.title()}!")


greet_user('jesse')
# making a list with three names
# defining a function
# the variable within the parenthesis is a parameter,
# information needed for the function to do it's job
# 'jesse' is a value and an argument
# passed from a function to call a function

for user in users:
    greet_user(user)
    # making a for loop
    # calling for the function for the list
    
Parameter:
The variable within the parenthesis is a parameter

Argument and value:
The ' ' in the parenthesis is the the value and argument 


A funtion definition can have multiple parameters:
Arguments can be passed to the punction through positional arguments (in the same order as the parameters were written),
keyword arguments (where each argument contains varibale name and value, list and dictionaries of values.


# positional arguments
# is when parameters and the arguments/values are in the same order
def describe_pet(animal_type, pet_name):
    # making a function which contains two parameters
    """Display information about a pet."""
    print((f"\nI have a {animal_type}."))
    print(f"My {animal_type}'s name is {pet_name.title()}.")


describe_pet('hamster', 'harry')
# calling for function and giving the values that connects with the parameters
# animal_type = 'hamster
# pet_name = 'harry'

# multiple functions call
describe_pet('dog', 'willie')
# we can change the value and the function work the same
# but the new values will be printed instead

# keyword argument (is a name-value pair)
describe_pet(animal_type='hamster', pet_name='harry')


# when using keyword arguments the order doesn't matter
# it's specifies where each value should go

# default value 
def describe_pet(pet_name, animal_type='dog'):
    # if there is information that  is constant
    # we can write a default value where we usually write parameters
    """Display information about a pet."""
    print((f"\nI have a {animal_type}."))
    print(f"My {animal_type}'s name is {pet_name.title()}.")
    # it's not enough to have parameters and arguments
    # we need to print for the function to be visible


describe_pet(pet_name='willie')
describe_pet(pet_name='berit')
print("\n")
describe_pet(pet_name='harry', animal_type='hamster')
# when we define the value when calling for the function
# python disregards the default value
# default value need to be listen after all parameters \
# that dont have default value
print("******************")

describe_pet('willie')
describe_pet(pet_name='willie')
print("\n**")

describe_pet('harry', 'hamster')
describe_pet(pet_name='harry', animal_type='hamster')
describe_pet(animal_type='hamster', pet_name='harry')
# the function we called the three last times all have the same output
# we can use different styles according to what works best for us

# avoiding argument errors
# if we in the function define parameters, we also need to write arguments
# it's helpful to give variables and functions descriptive names
# if an error occurs the messages will be more useful

# returning a simple value
def get_formatted_name(first_name, last_name):
    # defining function, including parameters
    """Return a full name neatly formatted"""
    full_name = (f"{first_name} {last_name}")
    # making variable that combines the two parameters
    return full_name.title()
    # returning full name starting with upper case letter


musician = get_formatted_name('jimi', 'hendrix')
# creating a variable which equals calling the function and including values
print(musician)


# making an argument optional
def get_formatted_name(first_name, middle_name, last_name):
    """Return a full name, neatly formatted."""
    full_name = (f"{first_name} {middle_name} {last_name}")
    return full_name.title()


musician = get_formatted_name('john', 'lee', 'hooker')
print(musician)

print("\n\n")


# making an argument optional
def get_formatted_name(first_name, last_name, middle_name=''):
    """Return a full name, neatly formatted."""
    if middle_name:
        # if the middle name is included in the function call
        # the condition is met and the full name will be printed
        full_name = (f"{first_name} {middle_name} {last_name}")
    else:
        full_name = (f"{first_name} {last_name}")
        # if not, the first and the last name will be printed
    return full_name.title()


musician = get_formatted_name('john', 'hooker', 'lee')
print(musician)

# returning a dictionary
def build_person(first_name, last_name, age=''):
    """Return a dictionary of information about a person."""
    person = {'first': first_name, 'last': last_name}
    # creating a dictionary where the value is the parameter
    if age:
        person['age'] = age
        # if age in included in the dictionary person
    return person


musician = build_person('jimi', 'hendrix', age=27)
print(musician)


# using a function with a while loop
def get_formatted_name(first_name, last_name):
    # in this exercise, the parameters are not defined
    # there will be an input which will create the value
    """Return full name, neatly formatted."""
    full_name = (f"{first_name} {last_name}")
    return full_name.title()
    # it is defined how the name will be returned


while True:
    print("\nPlease tell me your name:")
    print("(enter q at any time to quit)")
    f_name = input("First name: ")
    if f_name == 'q':
        break

    l_name = input("Last name: ")
    if l_name == 'q':
        break

    formatted_name = get_formatted_name(f_name, l_name)
    # here we are using the values from the input
    print(f"\nHello, {formatted_name}!")
    # and printing them in this sentence

# passing a list
def greet_users(names):
    # parameter 'names'
    """Print a simple greeting to each user in the list."""
    for name in names:
        msg = f"Hello,  {name.title()}!"
        print(msg)
        # for each name in names, 'msg' will be printed


usernames = ['hanna', 'ty', 'margot']
# creating a list will all users which will be greeted
greet_users(usernames)
# this connects to the function because usernames are outside the for loop
# inside the function we described what we want to happen
# when we call the function we point to who it is directed to

# modifying a list in a function
# when passing a list to a function,
# the function can modify the list

unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []
# one list with orders and one empty for those who are finished

while unprinted_designs:
    # as long as there are itens in the list of unprinted_designs
    current_design = unprinted_designs.pop()
    # the current design equals unprinted_designs
    # pop() starts from the end of the list
    print("Printing model: " + current_design)
    # printing message with the finished model
    completed_models.append(current_design)
    # adding the finished model to the list completed_models

print("\n")

print("The following models have been printed:")
for completed_model in completed_models:
    print(completed_model)
    # the for loop starts when the while statement are no longer valid
    # when the list of items are finished
    # the for loop the prints all items that have been completed


def print_models(unprinted_designs, completed_models):
    """Simulate printing each design, until none are left.
    Move each design to completed_models after printing."""

    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print("Printing model: " + current_design)
        completed_models.append(current_design)


def show_completed_models(completed_models):
    """how all the models that were printed"""
    print("The following models have been printed:")
    for completed_model in completed_models:
        print(completed_model)


unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
print("\n")
show_completed_models(completed_models)
# instead of a big chunk of code, we use the function
# so we can just can for the function for the same thing to happen
# which makes the code more efficient, bcs we if we need to change something
# we only need to do it in one place

# preventing a function from modifying a list
function_name(list_name[:])
# makes copy of the list if we don't want to change the original
print_models(unprinted_designs[:], completed_models)
# the functions will work as before but the original list is intact
# only the copy will change
# it's more efficient to work with an original though

*****

Exercise with function, copying a list 

def make_great(magicians_old, magicians_new):
    # the parameters can be any name
    # therefore, we want them to be as decriptive as possible,
    # so the code is easy to read
    """making copy of list"""

    while magicians_old:
        current_magician = magicians_old.pop()
        # the variable defines current magician as the old
        # using pop to remove from the list
        # we are using pop with the !parameter!
        magicians_new.append(current_magician)
        # again using the parameter when appending current magician
        print(f"Copying {current_magician.title()} into the new list.")


magicians = ['fyr', 'leo', 'kyro', 'seth']
# list of old magicians
magicians_copy = []
# list of new magicians

print("\n")
make_great(magicians[:], magicians_copy)
# make sure to put the names of list when calling the function
# we use positional argument and magicians[:} equals magicians_old
# magicians_copy equals magicians_new

print(magicians)
# printing the original list
print(magicians_copy)
# printing the copy

*****

# passing an arbitrary number of arguments
def make_pizza(*toppings):
    # * creates an empty tuple and includes whatever value it receives
    """Print the list of toppings that have been requested."""
    print(toppings)


make_pizza('pepperoni')
# first time we call the function, we added one topping
make_pizza('mushrooms', 'green peppers', 'extra cheese')


# second time we call the function we added three toppings


def make_pizza(*toppings):
    """Summarize the pizza we are about to make."""
    print("\nMaking pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")


make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')


# mixing positional and arbitrary arguments
# python takes positional and keyword arguments first
# therefore size goes first of the parameters

def make_pizza(size, *toppings):
    print(f"\nMaking a {str(size)}-inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")


make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')



def build_profile(first, last, **profile):
# the last parameter is the dictionary
# the first two parameters are included in this dictionary
    """Build a dictionary containing everything we know about a user."""
    profile['first_name'] = first
    profile['last_name'] = last

    for key, value in profile.items():
        profile[key] = value
        return profile


user_profile = build_profile('Maria (Marusha)', 'Nikiforova',
                             Occupation='Revolutionary',
                             Location='Ukraine',
                             Responsibility='Military command', )

print(user_profile)

#using important to call for functions in modules
import pizza

# imports the function in pizza.py
# if we keep the function without situation specifics,
# it can be applied in different situations

pizza.make_pizza(16, 'pepperoni')
pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')


import filename.py
module_name.function_name(arguments) → is how we call for the module
The function name is the name from the module we are calling

We can also import a specific function from a module:
from module_name import function_name		or:
from module_name import function_name1, function_name2, function_name3

# alias for function name
from module_name import function_name as xx

# alias for module name
import pizza as p

# importing all functions
from module_name import * → this imports every function in the module
If we import all we only need to use the function name when calling for it



# creating and using a class
# the _init_ method

class Dog():
    # when defining a class we start with an uppercase letter in python
    """A simple attempt to model a dog."""

    def __init__(self, name, age):
        # init method run automatically whenever we create a new instance
        # self parameter always need to be included and first
        # self is a reference to the instance
        # a function that is a part of a class is called a method
        """Initialize name and age attributes."""
        self.name = name
        # the prefix self makes the variable available to every method,
        # in the class (method = functions)
        # variables accessible through instances are called attributes
        self.age = age

    def sit(self):
        """Simulate a dog sitting in response to a command."""
        print(f"{self.name.title()} is now sitting.")

    def roll_over(self):
        """Simulating rolling over in response to a command."""
        print(f"{self.name.title()} rolled over!")


my_dog = Dog('willie', 6)
print(f"My dog's name is {my_dog.name.title()}.")
# adding.name makes it possible to access the value of my_dog
print(f"My dog is {str(my_dog.age)} years old.")

my_dog.sit()
my_dog.roll_over()
print("\n")

your_dog = Dog('lucy', 3)
print(f"Your dog's name is {your_dog.name.title()}.")
print(f"Your dog is {str(your_dog.age)} years old.")
your_dog.sit()


# working with classes and instances

class Car():

    def __init__(self, make, model, year):
        """Initialize attributes to describe a car."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0
        # setting a default value for an attribute

    def get_descriptive_name(self):
        """Return neatly formatted descriptive name."""
        long_name = f" {str(self.year)} {self.make} {self.model}"
        return long_name.title()

    def update_odometer(self, mileage):
        """Set the odometer to the given value.
        Reject the change if it attempts to roll the odometer back"""

        if mileage >= self.odometer_reading:
            # if a new number given is less than previous,
            # there will be a warning message
            self.odometer_reading = mileage
            # creating a new parameter
        else:
            print("You can't roll back an odometer!")

    def read_odometer(self):
        """print a statement showing the car's mileage."""
        print(f"This car has {str(self.odometer_reading)} miles on it.")

    def increment_odometer(self, miles):
        # when we use this method,
        # the number given in parenthesis will be added to the existing
        """Add the given amount to the odometer reading"""
        self.odometer_reading += miles


my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())
my_new_car.read_odometer()

my_new_car.odometer_reading = 23
my_new_car.read_odometer()

my_new_car.update_odometer(23)
my_new_car.read_odometer()

my_new_car.update_odometer(56)
my_new_car.read_odometer()

my_used_car = Car('subaru', 'outback', 2013)
print(my_used_car.get_descriptive_name())

my_used_car.update_odometer(23500)
my_used_car.read_odometer()

my_used_car.increment_odometer(100)
# this adds 100 to the updates value which is 23500
my_used_car.read_odometer()


# the __init__() method for child class
class Car():
    # parent class

    def __init__(self, make, model, year):
        """Initialize attributes to describe a car."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        """Return neatly formatted descriptive name."""
        long_name = f" {str(self.year)} {self.make} {self.model}"
        return long_name.title()

    def update_odometer(self, mileage):
        """Set the odometer to the given value.
        Reject the change if it attempts to roll the odometer back"""

        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def read_odometer(self):
        """print a statement showing the car's mileage."""
        print(f"This car has {str(self.odometer_reading)} miles on it.")

    def increment_odometer(self, miles):
        """Add the given amount to the odometer reading"""
        self.odometer_reading += miles


class Battery():
    """A simple attempt to model a battery for an electric car."""

    def __init__(self, battery_size=70):
        """Initialize the battery's attribute."""
        self.battery_size = battery_size

    def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {str(self.battery_size)}kWh battery.")
        # be aware of which order you place the classes in the program
        # it matters for how the code will be understood
        # Battery() need to be above Electric_car() in the program

    def get_range(self):
        """Print a statement about the range this battery provides."""
        if self.battery_size == 70:
            range = 240
        elif self.battery_size == 85:
            range = 270

        message = f"This car can go approximately {str(range)}"
        message += " miles on a full charge."
        print(message)


class Electric_car(Car):
    # in the parenthesis we refer to the parent class Car
    """Represent aspects of a car, specific to electric vehicles."""

    def __init__(self, make, model, year):
        # the information needed to make a car instance
        """Initialize attribute of the parent class."""
        super().__init__(make, model, year)
        # the super().__init__ function makes the connection between the
        # parent (superclass) and child class (subclass)
        # and gives the child class all attributes of the parent class
        self.battery = Battery()

    def fill_gas_tank(self):
        """Electric cars don't have gas tanks."""
        print("This car doesn't need a gas tank!")
        # if there is a method like this in the parent class
        # we can define the method in the child class with new information
        # instead of filling the gas tank, this message will be printed


my_tesla = Electric_car('tesla', 'model s', 2016)
# making an instance, storing arguments in variable my_tesla
print(my_tesla.get_descriptive_name())
# calling a method in parent class
my_tesla.battery.describe_battery()
# calling method in Battery() class
my_tesla.battery.get_range()

Steps for calling the class and methods:
# 1. if you have a list --> it should be at the end , after the method
# 2. make a variable for the class and if inheritance: add parameters in parenthesis
# 3. write the variable from point 2, the method you want to call and
# within parenthesis the variable that contains the arguments/values


# importing classes
from car import Car, Electric_car

# from the file car, two classes are imported

my_beetle = Car('volkswagen', 'beetle', 2016)
# positional arguments for beetle
print(my_beetle.get_descriptive_name())
# calling the method in class Car

my_tesla = Electric_car('tesla', 'roadster', 2016)
# positional arguments for tesla
print(my_tesla.get_descriptive_name())
# calling the method in class Car

# importing modules
import car

my_beetle = car.Car('volkswagen', 'beetle', 2016)
# when we import the whole module we need to define -->
# the name of the document as well as the class
print(my_beetle.get_descriptive_name())
# we can call the method as usual

my_tesla = car.Electric_car('tesla', 'roadster', 2016)
print(my_tesla.get_descriptive_name())

## to import all classes from a module:
# we write --> from module_name import * <--
# not recommended bcs unclear whicih classes are being used
# errors if the import has the same name as something else in the file


importing random class
from random import randrange


class Dice():
    """printing random numbers."""

    def __init__(self, sides=6):
        """Initializing the dice class."""
        self.sides = sides

    def roll_die(self):
        """Rolling the die."""
        message = f"The die has {self.sides} sides. " \
                  f"Press enter to roll the die"
        enter = input(message)
        x = int(self.sides) + 1
        # making the range 1, whatever argument is given for sides
        if enter == '':
            # if the user enters space, it returns a number
            range = randrange(1, x)
            return range
        else:
            print("no")
            quit()

    def result(self):
        """Printing result"""
        res = self.roll_die()
        print(f"The result is: {res}")


roll = Dice(6)
# die with six sides
roll.result()

Self in classes
In the above example, self refers to the name variable of the entire Person class. 
Here, if we have a variable within a method, self will not work. That variable is 
simply existent only while that method is running and hence, is local to that method. 
For defining global fields or the variables of the complete class, we need to define 
them outside the class methods.


# opening and reading a file

with open('pi_digits.txt') as file_object:
    # we are using with open instead of open() and close()
    # There can be bugs that can result in file not being closed which can cause
    # problems in the code
    # with this, we also don't need to decide when to close
    # python will close when it's no longer needed
    contents = file_object.read()
    # storing the reading of file in a variable
    print(contents.rstrip())
    # removing the extra space that appears with read()
    
python will look for the text file where the program is located.
if we want to refer to a file in another folder we have to specify the path.
ie. with open('folder_name/name_of_file.txt') as x: --> we can chose any representation name
# this is a relative path
# absolute file path can be read from any location, though need to be specific
file_path = ‘/home/xx/other_files_text_files/name_of_file.text’
with open(file_path) as file_object
# it’s easier to make the absolute file path into a variable. 


# reading line by line
filename = 'pi_digits.txt'
# we store the name of the file in a variable
# the name of the file only tells us where the file is located
with open(filename) as file_object:
    lines = file_object.readlines()
    # storing the file representation inside with block
    # readlines() takes each line from the file and stores it in a list

for line in lines:
    print(line.rstrip())
    # using for loop to print each lines

# using replace() to change word inside a textfile

filename_2 = 'learning_python.txt'
with open(filename_2) as text:
    lines = text.readlines()
    # reading each line in the text

    for line in lines:
        line = line.replace('Python', 'C')
        line = line.replace('python', 'C')
        line = line.replace('program', 'world peace')
        # we can make as many replacements as we want
        # important to cover both upper case letters and lower case letters

        print(line)
        # printing inside the for loop
   
        
# writing information to a file

filename = 'programming.txt'

with open(filename, 'a') as file_object:
    # 'w' opens the file in write mode
    # 'r+' is read and write mode
    # default mode if unspecified is read only
    file_object.write("I love programming.\n")
    # python can only store string data
    # numerical data need to be converted
    file_object.write("I love creating new games.\n")
    file_object.write("I also love finding meaning in large datasets.\n")
    file_object.write("I love creating apps that can run in a browser.\n")
    # after we've used 'w' to write data into the text file
    # we can change and use 'a' so that the data that already exist won't
    # be deleted. 'a' means append and will add the data ti the end of the file


# try, except, else blocks

print("Give me two numbers and I'll divide them.")
print("Enter 'q' to quit.")

while True:
    first_number = input("\nFirst number: ")
    if first_number == 'q':
        break
    second_number = input("Second number: ")
    if second_number == 'q':
        break

    try:
        answer = int(first_number) / int(second_number)

    except ZeroDivisionError:
        print("You can't divide by zero!")
        # the exception is anticipated and instead os showing traceback
        # it prints this message
        # this creates a more solid program
        # and at the same time it allows for the program to keep running

    else:
        print(answer)

# try works, the except block will be disregarded
# if a code doesn't work with try, python will run the exception
# we are creating a way for python to deal with the error


# working with multiple files

def count_words(filename):
    """Count the approximate number of words in a file."""

    try:
        with open(filename, encoding='utf-8') as f:
            contents = f.read()

    except FileNotFoundError:
        pass
        # with pass the user see the word count for the existing files
        # the error is not a traceback nor a message
        # the program simply skips the file that can't be read/is not existing
        # print(f"Sorry, the file {filename} does not exist.")

    else:
        words = contents.split()
        num_words = len(words)
        print(f"The file {filename} has about {num_words} words.")


filename = 'alice.txt'
count_words(filename)

filenames = ['alice.txt', 'siddharta.txt', 'moby_dick.txt', 'little_women.txt']
for filename in filenames:
    count_words(filename)
    # making a function makes the code more efficient
    # we can apply this to any text where we want to count words
    # the try except is helpful since it allows the program to run even
    # after encountering an error

def count_words(filename, word):
    """Counting specific word in book."""
    word = word

    try:
        with open(filename, encoding='utf-8') as f:
            contents = f.read()

    except FileNotFoundError:
        pass

    else:
        number = contents.lower().count(word)
        # text is case sensitive and we need to use lower()
        # to get the accurate number
        # lower() and count() can go next to each other
        # 3389 without space
        # 2276 with space
        print(f"The file {filename} contains {number} of the word: {word}.")


filenames = ['immortals_without_a_god.txt', 'alice.txt', 'siddharta.txt',
             'moby_dick.txt', 'little_women.txt']

count_words(filenames[0], 'mountain')
count_words(filenames[1], 'love')
count_words(filenames[3], 'class')
# using index to choose which file from the list to search
# second argument defines the word

word = 'alice'
for filename in filenames:
    count_words(filename, word)
    # for loop is more useful if we want to search for the
    # same word in all files


import json


# refactoring the code
# the first function calls the username
# The second prints a greeting
# if the user doesn't exist, it prompts the user the enter data

def get_stored_username():
    """Get stored username if available."""
    filename = 'username.json'
    try:
        with open(filename) as f:
            username = json.load(f)
    except FileNotFoundError:
        return None
    else:
        return username


def greet_user():
    """Greet the user by name."""
    username = get_stored_username()
    if username:
        print(f"Welcome back, {username}!")
    else:
        username = input("What is your name? ")
        filename = 'username.json'
        with open(filename, 'w') as f:
            json.dump(username, f)
            print(f"We'll remember you when you come back, {username}!")


greet_user()


# name function
def get_formatted_name(first, last, middle=''):
    """Generate a neatly formatted full name."""
    if middle:
        full_name = f"{first} {middle} {last}"
    else:
        full_name = f"{first} {last}"
    return full_name.title()
    
    
import unittest
from name_function import get_formatted_name


# test name function
class NamesTestCase(unittest.TestCase):
    """Tests for 'name_function.py'."""

    # it's helpful to use the word Test when naming the class
    # the class inherits from unittest.Testcase

    def test_first_last_name(self):
        """Do names like Janis Joplin work?"""

        formatted_name = get_formatted_name('janis', 'joplin')
        # calling th function we want to test
        self.assertEqual(formatted_name, 'Janis Joplin')
        # assertEqual() is a unittest method to verify that
        # the received result matches expected result -->
        # comparing the value in formatted_name with 'Janis Joplin'

    # when running test --> a dot on the first line means that a
    # single test passed

    def test_first_last_middle_name(self):
        """Do names like Wolfgang Amadeus Mozart' work?"""

        formatted_name = get_formatted_name(
            'wolfgang', 'mozart', 'amadeus')
        self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')


if __name__ == '__main__':
    unittest.main()

************************
    
# Assert Methods from unittest Module
assertEqual(a,b)  -- verify that a == b
assertNotEqual(a, b) -- verify that a != b
assertTrue(x) -- verify that x is True
assertFalse(x) -- verify that x is False
assertIn(item, list) -- verify that item is in list
assertNotIn(item, list) -- verify that item is not in list

*************************

# Unittest

# program
# using remove() to remove all instances of value from a list

class NoRepetition:
    """Making a class to remove an item from a list."""

    def __init__(self, all_items, item):
        self.all_items = all_items
        self.item = item

    def poppingItem(self):
        """Removing specific items from a list."""

        while self.item in self.all_items:
            self.all_items.remove(self.item)
            # using the while loop to delete all 'cat' values in the list
            # the loop ensures that the loop continues until all 'cat'
            # are removed

    def printPoppedItem(self):
        """Printing the item that was popped."""
        print(f"This is the removed item: {self.item}")


# test for program

import unittest
from pets import NoRepetition


class TestNoRepetition(unittest.TestCase):
    """Testing class NoRepetition."""

    def setUp(self):
        pet_list = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
        remove_animal = 'cat'
        self.repetition = NoRepetition(pet_list, remove_animal)

    def testPoppingItem(self):
        """Testing method PoppedItem."""
        self.repetition.poppingItem()

    def testPrintPoppedItem(self):
        """Testing method printPoppedItem."""
        self.repetition.printPoppedItem()


if __name__ == '__main__':
    unittest.main()

Projects Data visualization

# creating graphs with matplotlib

import matplotlib.pyplot as plt

input_values = [1, 2, 3, 4, 5]
# plot assumes that the first data point is 0
# this is the default behavior
# by adding this variable, we override the default
squares = [1, 4, 9, 16, 25]
# list containing a square number sequence
plt.style.use('seaborn')
# >>> import matplotlib.pyplot as plt
# >>> plt.style.available
# to see the available styles
fig, ax = plt.subplots()
# subplots() exists within pyplot
# can generate one or more plots within the same figure
# variable fig represent the entire figure (the collection of plots)
# variable represent a single plot
ax.plot(input_values, squares, linewidth=3)
# plotting the data
# linewidth makes the line thicker than default
ax.set_title("Square Numbers", fontsize=24)
# The overall title at the top
ax.set_xlabel("Value", fontsize=14)
# title on horizontal axis
ax.set_ylabel("Square of value", fontsize=14)
# title on vertical axis
ax.tick_params(axis='both', labelsize=14)
# styles the tick marks on both axis

plt.show()
# opens Matplotlib's viewer to show the data

# scatter_squares
import matplotlib.pyplot as plt

x_values = range(1, 1001)
# x values are the numbers to be squared
# range is 1-1000
y_values = [x ** 2 for x in x_values]
# contains the square of each number
# making a for loop for the calculation
# x**2 is square
# results stored in y_values

plt.style.use('seaborn')
fig, ax = plt.subplots()
ax.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, s=10)
# s variable defines the size of the dots
# c defines the color which can be expressed like 'red', 'green' etc
# or with RGB color model. 0 produces dark colors and values
# closer to 1 lighter colors
# cmap=plt.cm.Blues results in lower y values are lighter blue
# and the higher values are darker blue

ax.set_title("Square Numbers", fontsize=24)
ax.set_xlabel("Value", fontsize=14)

ax.set_ylabel("Square of Value", fontsize=14)
ax.tick_params(axis='both', which='major', labelsize=14)
ax.axis([0, 1100, 0, 1100000])
# axis method requires four values
# the minimum and the maximum values for the x and y axis
# specifying the range for each axis
plt.show()
# if we want to save the plot to a file we can instead of show() use:
# plt.savefig('squares_plot.png', bbox_inches='tight')
# 'squares_plot.png' is the filename
# bbox_inches='tight' takes away whitespace around the plot







	
		
